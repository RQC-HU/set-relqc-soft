#!/usr/bin/env bash
set -euo pipefail

function trap_sigint() {
	echo "trap is detected(sigint)"
	# exit with SIGINT
	exit 130 # 128 + 2(SIGINT)
}
trap trap_sigint sigint

function print_usage() {
	echo "Usage: $0 [options]"
	echo "Options:"
	echo "  --help|-h: print this help"
	echo "  --prefix <path>: installation path"
	echo "  --parallel <parallel>: number of processors for build"
	echo "  --overwrite: overwrite existing installation directory"
}

function check_parameter() {
	if [ $# -lt 2 ]; then
		echo "ERROR: Missing parameter for $1"
		print_usage
		exit 1
	fi
}

function get_args() {
	# Default values
	INSTALL_PATH="$HOME"
	INSTALL_UTCHEM="NO"
	OVERWRITE="NO"
	SETUP_NPROCS=1

	# Parse arguments
	while [ $# -gt 0 ]; do
		case "$1" in
		--help | -h)
			print_usage
			exit 0
			;;
		--prefix)
			check_parameter "$@"
			INSTALL_PATH="$2"
			shift 2
			;;
		--parallel)
			check_parameter "$@"
			# check if the $2 is a natural number
			if ! [[ "$2" =~ ^[1-9][0-9]*$ ]]; then
				echo "ERROR: Invalid number of processors: $2"
				print_usage
				exit 1
			fi
			SETUP_NPROCS="$2"
			shift 2
			;;
		--overwrite)
			OVERWRITE="YES"
			shift
			;;
		*)
			echo "ERROR: Invalid argument: $1"
			print_usage
			exit 1
			;;
		esac
	done

	echo "INSTALL_UTCHEM: $INSTALL_UTCHEM"
	echo "INSTALL_PATH: $INSTALL_PATH"
	echo "SETUP_NPROCS: $SETUP_NPROCS"
}


function check_one_file_only() {
	if [ "$(echo "$FILE_NAMES" | wc -l)" -gt 1 ]; then
		echo "ERROR: Detected multiple $PROGRAM_NAME ${FILE_TYPE}s in $SCRIPT_PATH/$PROGRAM_NAME directory."
		echo "       Searched for $FILE_TYPE files named '$FIND_CONDITION'."
		echo "       Please remove all but one file."
		echo "Detected ${FILE_TYPE}s:"
		echo "$FILE_NAMES"
		echo "Exiting."
		exit 1
	fi
}

function test_utchem() {
	set +e
	echo "Start testing UTChem..."
	failed_test_files=()
	tests_count=0
	for TEST_SCRIPT_PATH in $(find "$UTCHEM_BUILD_DIR" -name "test.sh"); do
		HF="$(echo "$TEST_SCRIPT_PATH" | grep Hartree)"
		DFT="$(echo "$TEST_SCRIPT_PATH" | grep rtddft)"
		if [ "$HF" ] || [ "$DFT" ]; then
			TEST_SCRIPT_DIR="$(dirname "$TEST_SCRIPT_PATH")"
			cd "$TEST_SCRIPT_DIR"
			echo "Start Running a test script under: ${TEST_SCRIPT_DIR}"
			SCRATCH="scratch"
			TEST_RESULTS="test-results"
			mkdir -p ${SCRATCH} ${TEST_RESULTS}
			for ii in *.ut; do
				echo
				echo "=================================================================="
				echo "Testing... $ii"
				date
				OUTPUT="${ii}out"
				echo "Output file: ${OUTPUT}"
				echo "../../boot/utchem -n ${SETUP_NPROCS} -w ${SCRATCH} $ii >& ${TEST_RESULTS}/$OUTPUT"

				../../boot/utchem -n "${SETUP_NPROCS}" -w "${SCRATCH} $ii" >"${TEST_RESULTS}/$OUTPUT" 2>&1
				date
				echo "End running test script"

				tests_count=$(($tests_count + 1))
				# a.utout.nproc=1 a.utout.nproc=2 a.utout.nproc=4 => a.utout.nproc=4
				reference_output=$(ls "$TEST_SCRIPT_DIR/$OUTPUT" | tail -n 1)
				result_output="$TEST_SCRIPT_DIR/${TEST_RESULTS}/$OUTPUT"
				references=($(grep "Total Energy.*=" "$reference_output" | awk '{for(i = 1; i <= NF - 2; i++){printf $i}printf " " $NF " "}'))
				results=($(grep "Total Energy.*=" "$result_output" | awk '{for(i = 1; i <= NF - 2; i++){printf $i}printf " " $NF " "}'))

				echo "Start checking test results for $reference_output and $result_output..."
				echo "references: " "${references[@]}"
				echo "results: " "${results[@]}"
				if [ ${#references[@]} -ne ${#results[@]} ]; then
					failed_test_files+=("$result_output")
					echo "ERROR: references and results are not same length"
					echo "So we don't evaluate the results of Total Energy"
					echo "references:" "${references[@]}"
					echo "results:" "${results[@]}"
					continue
				fi

				for ((i = 1; i < ${#references[@]}; i += 2)); do
					diff=$(echo "${references[$i]} ${results[$i]}" | awk '{printf $1 - $2}')
					absdiff=${diff#-}
					threshold=1e-7
					is_pass_test=$(echo "${absdiff} ${threshold}" | awk '{if($1 <= $2) {print "YES"} else {print "NO"}}')
					all_test_passed="YES"
					echo "Checking abs(reference - result): ${absdiff} <= ${threshold} ? ... ${is_pass_test}"

					if [ "$is_pass_test" = "YES" ]; then
						echo "TEST PASSED"
					else
						all_test_passed="NO"
						echo "ERROR: TEST FAILED"
						echo "threshold = $threshold"
						echo "Difference between the reference and the result in the calculation of ${references[$((i - 1))]} is greater than the threshold."
						echo "references = ${references[$i]} Hartree"
						echo "results = ${results[$i]} Hartree"
						echo "abs(diff) = ${absdiff} Hartree"
						failed_test_files+=("$result_output")
					fi
				done
				if [ "$all_test_passed" = "YES" ]; then
					echo "ALL TESTS PASSED for $result_output"
				else
					echo "ERROR: SOME TESTS FAILED for $result_output"
				fi
				echo "End checking test results for $reference_output and $result_output..."
				echo "=================================================================="
				echo
			done
			echo "Finished Running test scripts under: ${TEST_SCRIPT_DIR}"
		fi
	done
	echo "Finished testing UTChem"
	echo "------------------------------------------------------------------"
	echo "Summary of UTChem tests"
	echo "ALL TESTS: ${tests_count}"
	echo "FAILED TESTS: ${#failed_test_files[@]}"
	if [ ${#failed_test_files[@]} -ne 0 ]; then
		echo "ERROR: SOME TESTS FAILED"
		echo "FAILED TESTS:"
		for failed_test in "${failed_test_files[@]}"; do
			echo "  $failed_test"
		done
	else
		echo "ALL TESTS PASSED!"
	fi
	echo "------------------------------------------------------------------"
	set -e
}

function setup_utchem() {
	echo "Start setup UTChem..."
	OMPI_VERSION="$OPENMPI4_VERSION"
	set_ompi_path # set OpenMPI PATH

	UTCHEM_PATCH=$(find "$SCRIPT_PATH/utchem" -maxdepth 1 -type d -name patches)
	UTCHEM_TARBALL=$(find "$SCRIPT_PATH/utchem" -maxdepth 1 -name "utchem*tar*")
	cp -f "${UTCHEM_TARBALL}" "${UTCHEM}"
	cp -rf "${UTCHEM_PATCH}" "${UTCHEM}"
	PATCHDIR=$(find "$SCRIPT_PATH/utchem" -maxdepth 1 -type d -name patches)

	# Unzip utchem.tar file
	cd "${UTCHEM}"
	mkdir -p "${UTCHEM}/utchem"
	tar -xf "${UTCHEM_TARBALL}" -C "${UTCHEM}/utchem" --strip-components 1
	UTCHEM_BUILD_DIR="${UTCHEM}/utchem"
	GA4="${UTCHEM_BUILD_DIR}/ga4-0-2"

	# File location of Patch files and files to patch
	GAMAKEFILE="${GA4}/ga++/GNUmakefile"
	GAPATCH="${PATCHDIR}/ga_patch"
	GLOBALMAKEFILE="${GA4}/global/GNUmakefile"
	GLOBALPATCH="${PATCHDIR}/global_patch"
	GACONFIGFILE="${GA4}/config/makefile.h"
	GACONFIGPATCH="${PATCHDIR}/makefile.h.patch"

	# Patch files (To run "make" command normally)
	patch "${GAMAKEFILE}" "${GAPATCH}"
	patch "${GLOBALMAKEFILE}" "${GLOBALPATCH}"
	patch "${GACONFIGFILE}" "${GACONFIGPATCH}"

	# Use ifort, gcc and g++ to build utchem (64bit linux machine)
	#   If you want to build utchem using gfortran, gcc and g++ (integer8),
	#       change linux_ifort_x86_64_i8.config.sh.in to linux_gcc4_x86_64_i8_config.sh.in and
	#       change linux_ifort_x86_64_i8.makeconfig.in to linux_gcc4_x86_64_i8_makeconfig.in.
	cd "${UTCHEM_BUILD_DIR}/config"
	cp -f linux_mpi_ifort_x86_64_i8.config.sh.in linux_ifc.config.sh.in
	cp -f linux_mpi_ifort_x86_64_i8.makeconfig.in linux_ifc.makeconfig.in

	# Configure utchem
	#   If your system don't have python in /usr/bin, you have to install python 2.x.x to your system
	#   and add the path where you installed python.
	#   (e.g. If you installed a python executable file at /home/users/username/python)
	#   ./configure --python=/home/users/username/python
	cd "${UTCHEM_BUILD_DIR}"
	UTCHEM_MPI="$(dirname "$(which mpiifort | xargs dirname)")"
	./configure --mpi="$UTCHEM_MPI" --python=python2 2>&1 | tee "$SCRIPT_PATH/utchem-make.log"

	# Make utchem (${UTCHEM_BUILD_DIR}/boot/utchem is executable file)
	make 2>&1 | tee "$SCRIPT_PATH/utchem-make.log"

	# Setup modulefiles
	cp -f "$SCRIPT_PATH/utchem/utchem" "${MODULEFILES}"
	echo "prepend-path  PATH	${UTCHEM_BUILD_DIR}/boot" >>"${MODULEFILES}/utchem"

	# Run test script
	test_utchem 2>&1 | tee "$SCRIPT_PATH/utchem-test.log"
	cd "$SCRIPT_PATH"

}


function check_utchem_files() {

	UTCHEM_PATCH=$(find "$SCRIPT_PATH/utchem" -maxdepth 1 -type d -name patches)
	UTCHEM_TARBALL=$(find "$SCRIPT_PATH/utchem" -maxdepth 1 -name "utchem*tar*")

	# Check if the license file and tarball exist
	if [ ! -d "${UTCHEM_PATCH}" ]; then
		echo "ERROR: UTCHEM patches directory not found."
		echo "Please check the file name (Searched for 'patches' in the '$SCRIPT_PATH/utchem' directory). Exiting."
		exit 1
	fi
	if [ -z "${UTCHEM_TARBALL:-}" ]; then
		echo "ERROR: UTCHEM Tarball file not found."
		echo "Please check the file name (Searched for 'utchem*tar*' in the '$SCRIPT_PATH/utchem' directory). Exiting."
		exit 1
	fi

	# Check if the number of tarball is one in the directory.
	FILE_NAMES="$UTCHEM_TARBALL"
	FILE_TYPE="tarball"
	FIND_CONDITION="utchem*tar*"
	PROGRAM_NAME="utchem"
	check_one_file_only
}

function check_files_and_dirs() {
	if [ "$INSTALL_UTCHEM" == "YES" ] || [ "$INSTALL_DIRAC" == "YES" ]; then
		mkdir -p "${OPENMPI}"
	fi
	if [ "$INSTALL_MOLCAS" == "YES" ]; then
		mkdir -p "${MOLCAS}"
		check_molcas_files
	fi
	if [ "$INSTALL_DIRAC" == "YES" ]; then
		mkdir -p "${DIRAC}"
	fi
	if [ "$INSTALL_UTCHEM" == "YES" ]; then
		mkdir -p "${UTCHEM}"
		check_utchem_files
	fi
}

function check_install_programs() {
	if [ "${INSTALL_DIRAC}" = "YES" ]; then
		if [ -z "${INSTALL_DIRAC_VERSIONS:-}" ]; then
			INSTALL_DIRAC_VERSIONS="all"
		fi
		if [ "$INSTALL_DIRAC_VERSIONS" = "all" ]; then
			cd "$SCRIPT_PATH/dirac"
			INSTALL_DIRAC_VERSIONS=$(ls -d -- *)
			cd "$SCRIPT_PATH"
		fi
		echo "You will install DIRAC versions:"
		echo "$INSTALL_DIRAC_VERSIONS"
		count=0
		for DIRAC_VERSION in $INSTALL_DIRAC_VERSIONS; do
			count=$((count + 1))
			if [ ! -d "$SCRIPT_PATH/dirac/$DIRAC_VERSION" ]; then
				echo "ERROR: DIRAC version $DIRAC_VERSION not found."
				echo "Please check the file name (Searched for '$DIRAC_VERSION' in the '$SCRIPT_PATH/dirac' directory). Exiting."
				exit 1
			fi
		done
		dirac_counts=$count
		echo "You will install $dirac_counts DIRAC versions."
	fi

	install_programs=("CMake (https://cmake.org/)")
	if [ "$INSTALL_MOLCAS" == "YES" ]; then
		install_programs+=("Molcas (https://molcas.org/)")
	fi
	if [ "$INSTALL_DIRAC" == "YES" ]; then
		install_programs+=("DIRAC (http://diracprogram.org/)")
	fi
	if [ "$INSTALL_UTCHEM" == "YES" ]; then
		install_programs+=("UTChem (http://ccl.scc.kyushu-u.ac.jp/~nakano/papers/lncs-2660-84.pdf)")
	fi
	if [ "$INSTALL_UTCHEM" == "YES" ] || [ "$INSTALL_DIRAC" == "YES" ]; then
		install_programs+=("OpenMPI (https://www.open-mpi.org/)")
	fi

	echo "The following programs will be installed:"
	# if install-programs.log exists, remove it
	if [ -f "${SCRIPT_PATH}/install-programs.log" ]; then
		rm "${SCRIPT_PATH}/install-programs.log"
	fi
	for program in "${install_programs[@]}"; do
		echo "$program" | tee -a "${SCRIPT_PATH}/install-programs.log"
	done
}

function set_install_path() {
	# Check if the variable is set
	if [ -z "${INSTALL_PATH:-}" ]; then
		echo "INSTALL_PATH is not set"
		INSTALL_PATH="${HOME}/software"
		echo "INSTALL_PATH is set to default install path: $INSTALL_PATH"
	fi

	# Check if the path exists
	# OVERWRITE is set to YES if the user wants to overwrite the existing installation
	if [ "${OVERWRITE}" = "YES" ]; then
		echo "!!!!!!!!!!!!!!!!!!!!! Warning: OVERWRITE option selected YES !!!!!!!!!!!!!!!!!!!!!"
		echo "Warning: OVERWRITE option selected YES.  may overwrite the existing path! $INSTALL_PATH."
		echo "If you want to keep the existing path, do not set OVERWRITE to YES."
		echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
		ANS="NO"
		read -p "Do you want to set OVERWRITE option selected YES? (y/N)" yn
		case $yn in
		[Yy]*) ANS="YES" ;;
		[Nn]*) ANS="NO" ;;
		*) ANS="NO" ;;
		esac
		echo "Your answer is $ANS"
		if [ "$ANS" = "NO" ]; then
			echo "OVERWRITE=YES was rejected by you. Exiting."
			exit 1
		fi
		echo "OVERWRITE option selected YES. may overwrite the existing path! $INSTALL_PATH."
	else
		if [ -d "$INSTALL_PATH" ]; then
			echo "$INSTALL_PATH is already exists"
			echo "Please remove the directory and run the script again or set the another path that does not exist."
			exit 1
		fi
	fi

	INSTALL_PATH="$user_submitted_dir/$INSTALL_PATH"
	# INSTALL_PATH=$(cd "$(dirname "${INSTALL_PATH}")"pwd)/$(basename "$INSTALL_PATH")
	mkdir -p "${user_submitted_dir}/${INSTALL_PATH}"
	echo "INSTALL_PATH is set to: $INSTALL_PATH"

}

function is_enviroment_modules_installed() {
	echo "Checking if the Enviroment Modules is already installed..."
	mkdir -p "${MODULEFILES}"
	if type module >/dev/null; then
		echo "Enviroment Modules is installed"
		echo "You can use module command to load the Modules under $MODULEFILES in your bashrc file."
		echo "(e.g. module use --append ${MODULEFILES})"
		module use --append "${MODULEFILES}"
		echo "module use --append ${MODULEFILES}" >>"$HOME/.bashrc"
		echo "Info: Add the modulefiles to your bashrc file. (module use --append ${MODULEFILES})"
	else
		echo "Enviroment Modules is not installed"
		echo "After Enviroment Modules is installed, you can use module command (c.f. http://modules.sourceforge.net/)"
		echo "You need to load the modules under $MODULEFILES in your bashrc file to use the modules configured in this script."
		echo "(e.g. module use --append ${MODULEFILES})"
	fi
}

## Main ##
\unalias -a
umask 0022
user_submitted_dir=$(pwd)
SCRIPT_PATH=$(cd "$(dirname "$0")" && pwd)
get_args "$@"
# Check whether the user wants to install or not
check_install_programs

bash "$SCRIPT_PATH/check_requirements"
echo "All requirements are configured. Proceeding..."

set_install_path
# python2 is required to install pyenv
if ! type python2 >/dev/null; then
	bash "$SCRIPT_PATH/setup-pyenv" --parallel "$SETUP_NPROCS"
fi

# Software path
MODULEFILES="${INSTALL_PATH}/modulefiles"
OPENMPI="${INSTALL_PATH}/openmpi-intel"
DIRAC="${INSTALL_PATH}/dirac"
MOLCAS="${INSTALL_PATH}/molcas"
UTCHEM="${INSTALL_PATH}/utchem"
mkdir -p "$UTCHEM"

# Check whether the environment modules (http://modules.sourceforge.net/) is already installed
is_enviroment_modules_installed

setup_python
setup_utchem

echo "End build UTChem"
wait
